/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/cartoon-girl-2.glb --types --transform -k -K -o src\components\CartoonGirl2Model.tsx 
Files: public/cartoon-girl-2.glb [734.93KB] > C:\Users\liujr\webdev\mystery-door\src\components\cartoon-girl-2-transformed.glb [213.99KB] (71%)
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useFrame, useGraph, useThree } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import { ActionState } from "/src/types";

type ActionName =
  | "door_open"
  | "camera_pull_in"
  | "girl_backing"
  | "peek_idle"
  | "cam_enter_bake"
  | "cam_pull_in_bake";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    panel: THREE.Mesh;
    handle: THREE.Mesh;
    ground: THREE.Mesh;
    frame: THREE.Mesh;
    frame_view: THREE.Mesh;
    girl002: THREE.SkinnedMesh;
    ["DEF-spine"]: THREE.Bone;
    ["DEF-pelvisL"]: THREE.Bone;
    ["DEF-pelvisR"]: THREE.Bone;
    ["DEF-thighL"]: THREE.Bone;
    ["DEF-thighR"]: THREE.Bone;
    ["DEF-shoulderL"]: THREE.Bone;
    ["DEF-upper_armL"]: THREE.Bone;
    ["DEF-shoulderR"]: THREE.Bone;
    ["DEF-upper_armR"]: THREE.Bone;
    ["DEF-breastL"]: THREE.Bone;
    ["DEF-breastR"]: THREE.Bone;
  };
  materials: {
    DoorColor: THREE.MeshStandardMaterial;
    Handel: THREE.MeshStandardMaterial;
    ground: THREE.MeshStandardMaterial;
    Girl: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export default function CartoonGirlModel({
  action = "init",
  showGround = true,
  setIsOpened,
  ...props
}: JSX.IntrinsicElements["group"] & {
  action?: ActionState;
  showGround?: boolean;
  setIsOpened: () => void;
}) {
  const group = React.useRef<THREE.Group>(null);
  const { scene, animations } = useGLTF("/cartoon-girl.glb") as GLTFResult;
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as GLTFResult;
  const { actions, mixer } = useAnimations(animations, group);

  const camPosRef = useRef<THREE.Group>(null);

  const [isCamMove, setIsCamMove] = useState(false);
  const enablePanRef = useRef(false);
  const [camOriginalPos, setCamOriginalPos] = useState(new THREE.Vector3());
  const [camOriginalQuat, setCamOriginalQuat] = useState(
    new THREE.Quaternion(),
  );
  const [camPanStartTime, setCamPanStartTime] = useState(0);

  const camera = useThree((state) => state.camera);
  const clock = useThree((state) => state.clock);

  materials.Girl.roughness = 0.4;

  useEffect(() => {
    if (camPosRef.current) {
      camPosRef.current.add(camera);
      camera.position.set(0, 0, 0);
      camera.rotation.set(-Math.PI / 2, 0, 0);
    }
  }, [camera]);

  useEffect(() => {
    if (
      !actions["peek_idle"] ||
      !actions["cam_pull_in_bake"] ||
      !actions["door_open"] ||
      !actions["girl_backing"] ||
      !actions["cam_enter_bake"]
    )
      return;

    // setIsCamMove(false);
    // initially i was using the above state `isCamMove` to control whether to
    // pan the camera in `useFrame`, but because react state setters are queued,
    // race condition happens, after effect sets `isCamMove` to false, there
    // can still be leftover `useFrame` callback calls, that changes cam pos
    // after animation has reset it.
    enablePanRef.current = false;

    let timerID: number | null = null;

    function onPullInFinished(
      e: THREE.Event<"finished", THREE.AnimationMixer> &
        THREE.AnimationMixerEventMap["finished"],
    ) {
      if (e.action === actions.cam_pull_in_bake) {
        const cam = camPosRef.current;
        if (cam) {
          setCamOriginalPos(cam.position.clone());
          setCamOriginalQuat(cam.quaternion.clone());
        }

        timerID = setTimeout(() => {
          // setIsCamMove(true);
          enablePanRef.current = true;
          setCamPanStartTime(clock.getElapsedTime());
        }, 1000);
      } else if(e.action === actions.cam_enter_bake) {
        
        timerID = setTimeout(() => {
          setIsOpened()
        }, 1000);
      }

    }

    mixer.addEventListener("finished", onPullInFinished);

    switch (action) {
      case "init":
        actions["cam_pull_in_bake"].stop();
        actions["cam_enter_bake"].stop();
        actions["door_open"].stop();
        actions["girl_backing"].stop();
        actions["peek_idle"].play();
        // camPosRef.current?.position.set(...[-11.201, 13.805, -30.777]);
        // camPosRef.current?.rotation.set(...[1.912, -0.131, 2.79]);
        break;

      case "pullIn":
        actions.cam_enter_bake.stop();

        actions["cam_pull_in_bake"].clampWhenFinished = true;
        actions["cam_pull_in_bake"].loop = THREE.LoopOnce;
        // actions["camera_pull_in"].timeScale = 0.2;
        actions["cam_pull_in_bake"]?.play();

        break;

      case "open":
        actions["peek_idle"]?.stop();
        actions["cam_pull_in_bake"]?.stop();

        actions["door_open"].clampWhenFinished = true;
        actions["door_open"].loop = THREE.LoopOnce;
        actions["door_open"]?.play();

        actions["girl_backing"].clampWhenFinished = true;
        actions["girl_backing"].loop = THREE.LoopOnce;
        actions["girl_backing"]?.play();

        actions["cam_enter_bake"].clampWhenFinished = true;
        actions["cam_enter_bake"].loop = THREE.LoopOnce;
        actions["cam_enter_bake"].timeScale = 1;
        actions["cam_enter_bake"]?.startAt(mixer.time + 0.1).play();
        break;

      default:
        break;
    }

    return () => {
      mixer.removeEventListener("finished", onPullInFinished);
      if (timerID) clearTimeout(timerID);
    };
  }, [actions, action, mixer, clock]);

  useFrame(({ clock }) => {
    const cam = camPosRef.current;

    // if (isCamMove && cam) {
    if (enablePanRef.current && cam) {
      const t = clock.getElapsedTime() - camPanStartTime;

      const a = Math.sin(t) * (Math.PI / 64);

      const p = camOriginalPos
        .clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), a);
      cam.position.copy(p);

      const o = camOriginalQuat.clone();
      const c = o.clone().conjugate();
      cam.quaternion.multiply(c.normalize());
      cam.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), a);
      cam.quaternion.multiply(o.normalize());
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="door">
          <mesh
            name="panel"
            geometry={nodes.panel.geometry}
            material={materials.DoorColor}
            position={[-0.635, 0.099, -0.066]}
            rotation={[0, 0.359, 0]}
            scale={0.825}
          >
            <mesh
              name="handle"
              geometry={nodes.handle.geometry}
              material={materials.Handel}
              position={[1.323, 1.218, 0.082]}
            />
          </mesh>
        </group>
        <group name="rig_export">
          <primitive object={nodes["DEF-spine"]} />
          <primitive object={nodes["DEF-pelvisL"]} />
          <primitive object={nodes["DEF-pelvisR"]} />
          <primitive object={nodes["DEF-thighL"]} />
          <primitive object={nodes["DEF-thighR"]} />
          <primitive object={nodes["DEF-shoulderL"]} />
          <primitive object={nodes["DEF-upper_armL"]} />
          <primitive object={nodes["DEF-shoulderR"]} />
          <primitive object={nodes["DEF-upper_armR"]} />
          <primitive object={nodes["DEF-breastL"]} />
          <primitive object={nodes["DEF-breastR"]} />
        </group>
        <group
          ref={camPosRef}
          name="camera_pos"
          position={[-11.201, 13.805, -30.777]}
          rotation={[1.912, -0.131, 2.79]}
        >
          <axesHelper args={[3]}></axesHelper>
        </group>

        {showGround && (
          <mesh
            name="ground"
            geometry={nodes.ground.geometry}
            material={materials.ground}
          />
        )}

        <mesh
          name="frame"
          geometry={nodes.frame.geometry}
          material={materials.DoorColor}
          scale={0.825}
        />
        {/* <mesh */}
        {/*   name="frame_view" */}
        {/*   geometry={nodes.frame_view.geometry} */}
        {/*   material={nodes.frame_view.material} */}
        {/*   position={[0, 1.164, -0.076]} */}
        {/*   rotation={[-Math.PI / 2, 0, 0]} */}
        {/*   scale={[0.66, 1, 1.097]} */}
        {/* /> */}
        <skinnedMesh
          name="girl002"
          geometry={nodes.girl002.geometry}
          material={materials.Girl}
          skeleton={nodes.girl002.skeleton}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/cartoon-girl.glb");
