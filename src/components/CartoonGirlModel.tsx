/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/cartoon-girl.glb --output src\components\CartoonGirl2Model.tsx --types --keepnames --keepgroups --exportdefault --transform --keepmeshes --keepmaterials --debug 
Files: public/cartoon-girl.glb [737.58KB] > C:\Users\liujr\webdev\mystery-door\src\components\cartoon-girl-transformed.glb [214.48KB] (71%)
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useFrame, useGraph, useThree } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import { ActionState } from "../types";

type ActionName =
  | "door_open"
  | "camera_pull_in"
  | "girl_backing"
  | "peek_idle"
  | "cam_enter_bake"
  | "cam_pull_in_bake";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    panel: THREE.Mesh;
    gem: THREE.Mesh;
    handle: THREE.Mesh;
    ground: THREE.Mesh;
    frame: THREE.Mesh;
    girl002: THREE.SkinnedMesh;
    ["DEF-spine"]: THREE.Bone;
    ["DEF-pelvisL"]: THREE.Bone;
    ["DEF-pelvisR"]: THREE.Bone;
    ["DEF-thighL"]: THREE.Bone;
    ["DEF-thighR"]: THREE.Bone;
    ["DEF-shoulderL"]: THREE.Bone;
    ["DEF-upper_armL"]: THREE.Bone;
    ["DEF-shoulderR"]: THREE.Bone;
    ["DEF-upper_armR"]: THREE.Bone;
    ["DEF-breastL"]: THREE.Bone;
    ["DEF-breastR"]: THREE.Bone;
  };
  materials: {
    DoorColor: THREE.MeshStandardMaterial;
    gem: THREE.MeshStandardMaterial;
    Handel: THREE.MeshStandardMaterial;
    ground: THREE.MeshStandardMaterial;
    Girl: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export default function CartoonGirlModel({
  action = "init",
  showGround = true,
  setIsFinishedOpen,
  ...props
}: JSX.IntrinsicElements["group"] & {
  action?: ActionState;
  showGround?: boolean;
  setIsFinishedOpen: () => void;
}) {
  const group = React.useRef<THREE.Group>(null);
  const { scene, animations } = useGLTF("cartoon-girl-transformed.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as GLTFResult;
  const { actions, mixer } = useAnimations(animations, group);

  const camPosRef = useRef<THREE.Group>(null);

  // const [isCamMove, setIsCamMove] = useState(false);
  const enablePanRef = useRef(false);
  const [camOriginalPos, setCamOriginalPos] = useState(new THREE.Vector3());
  const [camOriginalQuat, setCamOriginalQuat] = useState(
    new THREE.Quaternion(),
  );
  const [camPanStartTime, setCamPanStartTime] = useState(0);

  const camera = useThree((state) => state.camera);
  const clock = useThree((state) => state.clock);

  materials.Girl.roughness = 0.4;
  materials.gem.emissiveIntensity = 1.35;

  useEffect(() => {
    if (camPosRef.current) {
      camPosRef.current.add(camera);
      camera.position.set(0, 0, 0);
      camera.rotation.set(-Math.PI / 2, 0, 0);
    }
  }, [camera]);

  useEffect(() => {
    if (
      // !actions.camera_pull_in ||
      !actions["peek_idle"] ||
      !actions["cam_pull_in_bake"] ||
      !actions["door_open"] ||
      !actions["girl_backing"] ||
      !actions["cam_enter_bake"]
    )
      return;

    let timerID: number | null = null;

    function onFinished(
      e: THREE.Event<"finished", THREE.AnimationMixer> &
        THREE.AnimationMixerEventMap["finished"],
    ) {
      if (e.action === actions.cam_pull_in_bake) {
        const cam = camPosRef.current;
        if (cam) {
          setCamOriginalPos(cam.position.clone());
          setCamOriginalQuat(cam.quaternion.clone());
        }

        timerID = setTimeout(() => {
          // setIsCamMove(true);
          enablePanRef.current = true;
          setCamPanStartTime(clock.getElapsedTime());
        }, 200);
      } else if (e.action === actions.cam_enter_bake) {
        timerID = setTimeout(() => {
          setIsFinishedOpen();
        }, 500);
      }
    }

    mixer.addEventListener("finished", onFinished);

    switch (action) {
      case "init":
        actions["cam_pull_in_bake"].stop();
        actions["cam_enter_bake"].stop();
        actions["door_open"].stop();
        actions["girl_backing"].stop();

        actions.peek_idle.play();
        break;

      case "pullIn":
        actions.cam_enter_bake.stop();
        actions.door_open.stop();
        actions.girl_backing.stop();

        actions["cam_pull_in_bake"].clampWhenFinished = true;
        actions["cam_pull_in_bake"].loop = THREE.LoopOnce;
        // actions["camera_pull_in"].timeScale = 0.2;
        actions["cam_pull_in_bake"].play();
        actions.peek_idle.play();

        break;

      case "open":
        actions["peek_idle"].stop();
        actions["cam_pull_in_bake"]?.stop();

        actions["door_open"].clampWhenFinished = true;
        actions["door_open"].loop = THREE.LoopOnce;
        actions["door_open"].play();

        actions["girl_backing"].clampWhenFinished = true;
        actions["girl_backing"].loop = THREE.LoopOnce;
        actions["girl_backing"].play();

        actions["cam_enter_bake"].clampWhenFinished = true;
        actions["cam_enter_bake"].loop = THREE.LoopOnce;
        actions["cam_enter_bake"].timeScale = 1;
        actions["cam_enter_bake"].startAt(mixer.time + 0.1).play();

        // setIsCamMove(false);
        // initially i was using the above state `isCamMove` to control whether to
        // pan the camera in `useFrame`, but because react state setters are queued,
        // race condition happens, after effect sets `isCamMove` to false, there
        // can still be leftover `useFrame` callback calls, that changes cam pos
        // after animation has reset it.
        enablePanRef.current = false;

        break;

      default:
        break;
    }

    return () => {
      mixer.removeEventListener("finished", onFinished);
      if (timerID) clearTimeout(timerID);
    };
  }, [actions, action, mixer, clock, setIsFinishedOpen]);

  useFrame(({ clock }) => {
    const cam = camPosRef.current;

    // if (isCamMove && cam) {
    if (enablePanRef.current && cam) {
      const t = clock.getElapsedTime() - camPanStartTime;

      const a = Math.sin(t) * (Math.PI / 80);

      const p = camOriginalPos
        .clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), a);
      cam.position.copy(p);

      const o = camOriginalQuat.clone();
      const c = o.clone().conjugate();
      cam.quaternion.multiply(c.normalize());
      cam.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), a);
      cam.quaternion.multiply(o.normalize());
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="door">
          <mesh
            name="panel"
            geometry={nodes.panel.geometry}
            material={materials.DoorColor}
            position={[-0.635, 0.099, -0.066]}
            rotation={[0, 0.359, 0]}
            scale={0.825}
            castShadow
            receiveShadow
          >
            <mesh
              name="gem"
              geometry={nodes.gem.geometry}
              material={materials.gem}
              position={[0.768, 1.84, -0.035]}
              // rotation={[0, -0.359, 0]}
              scale={1.212}
            >
              {/* <axesHelper /> */}
              <pointLight
                position={[0, -0.03, -0.05]}
                color={"gold"}
                intensity={0.1}
                distance={0.33}
              >
                {/* <axesHelper /> */}
              </pointLight>
            </mesh>
            <mesh
              name="handle"
              geometry={nodes.handle.geometry}
              material={materials.Handel}
              position={[1.323, 1.218, 0.082]}
              castShadow
              receiveShadow
            />
          </mesh>
        </group>
        <group name="rig_export">
          <primitive object={nodes["DEF-spine"]} />
          <primitive object={nodes["DEF-pelvisL"]} />
          <primitive object={nodes["DEF-pelvisR"]} />
          <primitive object={nodes["DEF-thighL"]} />
          <primitive object={nodes["DEF-thighR"]} />
          <primitive object={nodes["DEF-shoulderL"]} />
          <primitive object={nodes["DEF-upper_armL"]} />
          <primitive object={nodes["DEF-shoulderR"]} />
          <primitive object={nodes["DEF-upper_armR"]} />
          <primitive object={nodes["DEF-breastL"]} />
          <primitive object={nodes["DEF-breastR"]} />
        </group>
        <group
          ref={camPosRef}
          name="camera_pos"
          position={[-11.201, 13.805, -30.777]}
          rotation={[1.912, -0.131, 2.79]}
        >
          {/* <axesHelper args={[1]} /> */}
        </group>
        {showGround && (
          <mesh
            name="ground"
            geometry={nodes.ground.geometry}
            material={materials.ground}
            receiveShadow
          />
        )}
        <mesh
          name="frame"
          geometry={nodes.frame.geometry}
          material={materials.DoorColor}
          scale={0.825}
          castShadow
          receiveShadow
        />
        <skinnedMesh
          name="girl002"
          geometry={nodes.girl002.geometry}
          material={materials.Girl}
          skeleton={nodes.girl002.skeleton}
          castShadow
          receiveShadow
        />
      </group>
    </group>
  );
}

useGLTF.preload("cartoon-girl-transformed.glb");
