/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/confetti.glb --types -k -K -o src/components/ConfettiModel.tsx 
*/

import * as THREE from "three";
import React, { useEffect } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { generateVibrantWarmBlueColor } from "../utils";
import { useFrame } from "@react-three/fiber";

type ActionName = "move_x_10" | "rot_x_1080";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    strip1_exp: THREE.Mesh;
    strip2_exp: THREE.Mesh;
    strip3_exp: THREE.Mesh;
  };
  materials: {
    shiny: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function ConfettiModel({
  stripType = 1,
  timeScale = 1,
  ...props
}: JSX.IntrinsicElements["group"] & {
  stripType?: number;
  timeScale?: number;
}) {
  const group = React.useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF(
    "confetti.glb",
  ) as GLTFResult;
  // console.log("confetti render");
  // console.log(animations);

  const { actions, mixer } = useAnimations(animations, group);

  const mat = materials.shiny.clone();
  mat.color.set(generateVibrantWarmBlueColor());
  mat.transparent = true;

  useEffect(() => {
    // console.log("confetti effect");

    if (!actions.rot_x_1080 || !actions.move_x_10)
      return () => {
        // console.log("confetti effect cleanup - no actions");
      };

    function onLoop() {
    // e: THREE.Event<"loop", THREE.AnimationMixer> &
    //   THREE.AnimationMixerEventMap["loop"],
      mat.color.set(generateVibrantWarmBlueColor());
    }

    mixer.addEventListener("loop", onLoop);
    actions.move_x_10.timeScale = timeScale;
    actions.rot_x_1080.timeScale = timeScale;
    actions.move_x_10.play();
    actions.rot_x_1080.play();

    return () => {
      // console.log("confetti effect - cleanup");
      mixer.removeEventListener("loop", onLoop);
    };
  }, [actions, timeScale, mixer, mat]);

  let strip = null;
  switch (stripType) {
    case 1:
      strip = (
        <mesh
          name="strip1_exp"
          geometry={nodes.strip1_exp.geometry}
          material={mat}
        />
      );
      break;
    case 2:
      strip = (
        <mesh
          name="strip2_exp"
          geometry={nodes.strip2_exp.geometry}
          material={mat}
        />
      );
      break;
    case 3:
      strip = (
        <mesh
          name="strip3_exp"
          geometry={nodes.strip3_exp.geometry}
          material={mat}
        />
      );
      break;
    default:
      break;
  }

  useFrame(() => {
    const action = actions.move_x_10;
    if (action) {
      // opacity ease-in/ease-out
      const progress = action.time / action.getClip().duration;
      const inThreshold = 0.2;
      const outThreshold = 0.8;
      const o =
        progress < inThreshold
          ? progress / inThreshold
          : progress > outThreshold
            ? 1 - (progress - outThreshold) / (1 - outThreshold)
            : 1;
      // console.log(o);
      mat.opacity = o;
    }
  });

  return (
    <group name="confetti" ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="subject">{strip}</group>
      </group>
    </group>
  );
}

useGLTF.preload("confetti.glb");
