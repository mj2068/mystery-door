/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/spiral-particle.glb --types -k -K -T -o src/components/SpiralParticleModel.tsx 
Files: public/spiral-particle.glb [1.53MB] > C:\Users\liujr\webdev\mystery-door\src\components\spiral-particle-transformed.glb [1.48MB] (4%)
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame, useThree } from "@react-three/fiber";

type ActionName = "KeyAction";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    particle001: THREE.Mesh;
  };
  materials: {
    emission: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function SpiralParticleModel({
  timeScale,
  ...props
}: JSX.IntrinsicElements["group"] & { timeScale: number }) {
  const group = React.useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF(
    "/spiral-particle-transformed.glb",
  ) as GLTFResult;

  // console.log(nodes);
  // console.log(animations);

  animations.forEach((clip) => {
    clip.duration = clip.tracks[0].times[clip.tracks[0].times.length - 2];
  });
  const { actions, mixer } = useAnimations(animations, group);

  const clock = useThree((state) => state.clock);
  const scene = useThree((state) => state.scene);

  // const aniStartedAtRef = useRef<number | null>(null);
  const [aniStartedAt, setAniStartedAt] = useState<number | null>(null);

  const mesh = nodes.particle001.clone();
  // console.log(mesh);

  const morph = nodes.particle001.morphTargetInfluences;
  const [morphTargetInfluences] = useState(morph && [...morph]);

  const mat = materials.emission.clone();
  mat.emissive.set(1, 1, 1);
  mat.transparent = true;
  // mat.opacity = 1;
  // mat.emissiveIntensity = 8;

  useEffect(() => {
    // console.log("effect");

    if (!actions.KeyAction)
      return () => {
        // console.log("effect cleanup - null KeyAction");
      };

    // console.log(group.current?.uuid);
    // console.log(
    //   (group.current?.children[0].children[0] as THREE.Mesh)
    //     .morphTargetInfluences === mesh.morphTargetInfluences,
    // );
    // console.log(mixer);

    actions.KeyAction.timeScale = timeScale;

    actions.KeyAction.play();

    // aniStartedAtRef.current = clock.getElapsedTime();
    setAniStartedAt(clock.getElapsedTime());

    return () => {
      // console.log("effect cleanup");
      actions.KeyAction?.stop();
    };
  }, [actions, timeScale, clock]);

  useFrame((_, delta) => {
    // if (aniStartedAtRef.current) {
    if (aniStartedAt) {
      // mat.emissiveIntensity -= 2 / (1.5 / delta);
      mat.opacity = Math.max(0, mat.opacity - (1 / 1.5) * delta);
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <mesh
          name="particle001"
          material={mat}
          geometry={nodes.particle001.geometry}
          morphTargetDictionary={nodes.particle001.morphTargetDictionary}
          morphTargetInfluences={morphTargetInfluences}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/spiral-particle-transformed.glb");
